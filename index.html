<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ulysses Tarot</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3CradialGradient id='sphereGrad' cx='40%25' cy='30%25'%3E%3Cstop offset='0%25' stop-color='%23f0e0ff'/%3E%3Cstop offset='50%25' stop-color='%23b88cff'/%3E%3Cstop offset='100%25' stop-color='%236600cc'/%3E%3C/radialGradient%3E%3ClinearGradient id='shineGrad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffffff' stop-opacity='0.8'/%3E%3Cstop offset='100%25' stop-color='%23ffffff' stop-opacity='0'/%3E%3C/linearGradient%3E%3Cfilter id='glow'%3E%3CfeGaussianBlur stdDeviation='2' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='35' fill='url(%23sphereGrad)' filter='url(%23glow)'/%3E%3Ccircle cx='50' cy='50' r='35' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.3'/%3E%3Cellipse cx='50' cy='35' rx='20' ry='15' fill='url(%23shineGrad)' opacity='0.6'/%3E%3Cpath d='M 30 50 Q 50 30 70 50 Q 50 70 30 50' fill='%23ffffff' opacity='0.2'/%3E%3Ccircle cx='50' cy='50' r='3' fill='%23ffffff' opacity='0.9'/%3E%3C/svg%3E">
    <link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3CradialGradient id='sphereGrad' cx='40%25' cy='30%25'%3E%3Cstop offset='0%25' stop-color='%23f0e0ff'/%3E%3Cstop offset='50%25' stop-color='%23b88cff'/%3E%3Cstop offset='100%25' stop-color='%236600cc'/%3E%3C/radialGradient%3E%3ClinearGradient id='shineGrad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ffffff' stop-opacity='0.8'/%3E%3Cstop offset='100%25' stop-color='%23ffffff' stop-opacity='0'/%3E%3C/linearGradient%3E%3Cfilter id='glow'%3E%3CfeGaussianBlur stdDeviation='2' result='coloredBlur'/%3E%3CfeMerge%3E%3CfeMergeNode in='coloredBlur'/%3E%3CfeMergeNode in='SourceGraphic'/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='35' fill='url(%23sphereGrad)' filter='url(%23glow)'/%3E%3Ccircle cx='50' cy='50' r='35' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.3'/%3E%3Cellipse cx='50' cy='35' rx='20' ry='15' fill='url(%23shineGrad)' opacity='0.6'/%3E%3Cpath d='M 30 50 Q 50 30 70 50 Q 50 70 30 50' fill='%23ffffff' opacity='0.2'/%3E%3Ccircle cx='50' cy='50' r='3' fill='%23ffffff' opacity='0.9'/%3E%3C/svg%3E">
    <style>
        :root {
            --primary: #e0e0e0;
            --bg: #0a0a0a;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Helvetica Neue', sans-serif;
            color: var(--primary);
            user-select: none;
        }
        
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 1s;
        }
        .spinner {
            width: 40px; height: 40px;
            background: #fff;
            animation: rotate 1.5s infinite ease-in-out;
        }
        @keyframes rotate { 
            0% { transform: rotate(0deg) scale(0.5); opacity: 0.5; } 
            50% { transform: rotate(180deg) scale(1); opacity: 1; } 
            100% { transform: rotate(360deg) scale(0.5); opacity: 0.5; } 
        }
        #loader-text {
            margin-top: 30px;
            color: rgba(255,255,255,0.7);
            font-size: 1rem;
            letter-spacing: 3px;
            text-align: center;
        }

        #intro-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9998;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s;
        }
        #intro-screen.active {
            opacity: 1;
            pointer-events: auto;
        }
        #intro-text {
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 1.1rem;
            letter-spacing: 2px;
            line-height: 2.2;
            margin-bottom: 60px;
        }
        #intro-text .line {
            opacity: 0;
            animation: showDirect 0s forwards;
            animation-delay: 0.3s;
        }
        @keyframes showDirect {
            to {
                opacity: 1;
            }
        }
        #intro-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 12px 40px;
            cursor: pointer;
            border-radius: 0;
            font-size: 1rem;
            letter-spacing: 3px;
            transition: all 0.3s;
            backdrop-filter: blur(4px);
            opacity: 0;
            animation: showDirect 0s forwards;
            /* 与文字同时出现 */
            animation-delay: 0.3s;
        }
        #intro-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        .top-bar {
            position: absolute;
            top: 20px; left: 20px; right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }
        .title {
            font-size: 1rem;
            letter-spacing: 4px;
            font-weight: 300;
            opacity: 0.8;
        }
        .btn-mode {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 6px 14px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 0.8rem;
            transition: all 0.3s;
            backdrop-filter: blur(4px);
        }
        .btn-mode:hover { background: rgba(255,255,255,0.2); }

        #video-preview {
            display: none !important;
        }

        #status-text {
            position: absolute;
            top: 72%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.1rem;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.6);
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #zone-indicator {
            position: absolute;
            left: 0;
            width: 4px;
            background: rgba(255,255,255,0.3);
            pointer-events: none;
            transition: top 0.1s ease-out, height 0.1s ease-out;
            z-index: 100;
            border-radius: 2px;
        }

        #hand-position-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.6);
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 200;
            transition: opacity 0.2s, transform 0.1s, border-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            opacity: 0;
        }

        #card-name {
            position: absolute;
            top: 13%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 3px;
            color: rgba(255,255,255,0.9);
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            opacity: 0;
            line-height: 1.4;
        }

        #card-interpretation {
            position: absolute;
            top: 87%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1rem;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            max-width: 600px;
            line-height: 1.6;
            opacity: 0;
            padding: 0 20px;
        }

        #drawn-cards-bar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 12px;
            pointer-events: auto;
            z-index: 10;
        }
        .drawn-card {
            width: 40px;
            height: 66px; /* Approx Tarot Ratio */
            border-radius: 4px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border: 1px solid rgba(255,255,255,0.2);
            opacity: 0;
            transform: translateY(20px);
            animation: slideUpFade 0.6s forwards;
            transition: transform 0.3s;
        }
        .drawn-card:hover { transform: scale(2.0) translateY(-20px); z-index: 20; border-color: #fff; }
        /* CSS rotation for reversed cards in UI */
        .drawn-card.reversed { 
            transform: rotate(180deg) translateY(0px);
        }
        .drawn-card.reversed:hover { 
            transform: rotate(180deg) scale(2.0) translateY(-20px); 
        }

        @keyframes slideUpFade { 
            to { 
                opacity: 1; 
                transform: translateY(0) !important; 
            } 
        }
        @keyframes slideUpFadeReversed { 
            to { 
                opacity: 1; 
                transform: rotate(180deg) translateY(0) !important; 
            } 
        }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loader-text">灵魂的欲望，是命运的先知</div>
    </div>

    <div id="intro-screen">
        <div id="intro-text">
            <div class="line">塔罗所见，仅是命运长河的一缕倒影</div>
            <div class="line">命如星辰已定，运似流云可塑</div>
            <div class="line">心念所及，便是变数所在</div>
        </div>
        <button id="intro-btn">探问命运</button>
    </div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="title">ULYSSES FATE 78</div>
            <button class="btn-mode" id="btn-mode" onclick="toggleInputMode()">MOUSE</button>
        </div>
        <div id="status-text"></div>
        <div id="card-name"></div>
        <div id="card-interpretation"></div>
        <div id="drawn-cards-bar"></div>
        <div id="zone-indicator"></div>
        <div id="hand-position-indicator"></div>
        <video id="input-video" style="display:none;" playsinline></video>
        <canvas id="video-preview"></canvas>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

    const BASE_URL = "./cards/";
    
    // --- Data Construction ---
    const MAJORS = [
        { name: "The Fool", url: "RWS_Tarot_00_Fool.png" },
        { name: "The Magician", url: "RWS_Tarot_01_Magician.jpg" },
        { name: "The High Priestess", url: "RWS_Tarot_02_High_Priestess.png" },
        { name: "The Empress", url: "RWS_Tarot_03_Empress.png" },
        { name: "The Emperor", url: "RWS_Tarot_04_Emperor.png" },
        { name: "The Hierophant", url: "RWS_Tarot_05_Hierophant.png" },
        { name: "The Lovers", url: "RWS_Tarot_06_Lovers.png" },
        { name: "The Chariot", url: "RWS_Tarot_07_Chariot.png" },
        { name: "Strength", url: "RWS_Tarot_08_Strength.png" },
        { name: "The Hermit", url: "RWS_Tarot_09_Hermit.png" },
        { name: "Wheel of Fortune", url: "RWS_Tarot_10_Wheel_of_Fortune.png" },
        { name: "Justice", url: "RWS_Tarot_11_Justice.png" },
        { name: "The Hanged Man", url: "RWS_Tarot_12_Hanged_Man.jpg" },
        { name: "Death", url: "RWS_Tarot_13_Death.png" },
        { name: "Temperance", url: "RWS_Tarot_14_Temperance.png" },
        { name: "The Devil", url: "RWS_Tarot_15_Devil.png" },
        { name: "The Tower", url: "RWS_Tarot_16_Tower.png" },
        { name: "The Star", url: "RWS_Tarot_17_Star.png" },
        { name: "The Moon", url: "RWS_Tarot_18_Moon.png" },
        { name: "The Sun", url: "RWS_Tarot_19_Sun.png" },
        { name: "Judgement", url: "RWS_Tarot_20_Judgement.png" },
        { name: "The World", url: "RWS_Tarot_21_World.png" }
    ];

    // Chinese card names mapping
    const CARD_NAMES_CN = {
        // Major Arcana
        "The Fool": "愚者",
        "The Magician": "魔术师",
        "The High Priestess": "女祭司",
        "The Empress": "皇后",
        "The Emperor": "皇帝",
        "The Hierophant": "教皇",
        "The Lovers": "恋人",
        "The Chariot": "战车",
        "Strength": "力量",
        "The Hermit": "隐者",
        "Wheel of Fortune": "命运之轮",
        "Justice": "正义",
        "The Hanged Man": "倒吊人",
        "Death": "死神",
        "Temperance": "节制",
        "The Devil": "恶魔",
        "The Tower": "塔",
        "The Star": "星星",
        "The Moon": "月亮",
        "The Sun": "太阳",
        "Judgement": "审判",
        "The World": "世界",
        // Minor Arcana - Wands (权杖)
        "Ace of Wands": "权杖王牌",
        "Two of Wands": "权杖二",
        "Three of Wands": "权杖三",
        "Four of Wands": "权杖四",
        "Five of Wands": "权杖五",
        "Six of Wands": "权杖六",
        "Seven of Wands": "权杖七",
        "Eight of Wands": "权杖八",
        "Nine of Wands": "权杖九",
        "Ten of Wands": "权杖十",
        "Page of Wands": "权杖侍从",
        "Knight of Wands": "权杖骑士",
        "Queen of Wands": "权杖皇后",
        "King of Wands": "权杖国王",
        // Minor Arcana - Cups (圣杯)
        "Ace of Cups": "圣杯王牌",
        "Two of Cups": "圣杯二",
        "Three of Cups": "圣杯三",
        "Four of Cups": "圣杯四",
        "Five of Cups": "圣杯五",
        "Six of Cups": "圣杯六",
        "Seven of Cups": "圣杯七",
        "Eight of Cups": "圣杯八",
        "Nine of Cups": "圣杯九",
        "Ten of Cups": "圣杯十",
        "Page of Cups": "圣杯侍从",
        "Knight of Cups": "圣杯骑士",
        "Queen of Cups": "圣杯皇后",
        "King of Cups": "圣杯国王",
        // Minor Arcana - Swords (宝剑)
        "Ace of Swords": "宝剑王牌",
        "Two of Swords": "宝剑二",
        "Three of Swords": "宝剑三",
        "Four of Swords": "宝剑四",
        "Five of Swords": "宝剑五",
        "Six of Swords": "宝剑六",
        "Seven of Swords": "宝剑七",
        "Eight of Swords": "宝剑八",
        "Nine of Swords": "宝剑九",
        "Ten of Swords": "宝剑十",
        "Page of Swords": "宝剑侍从",
        "Knight of Swords": "宝剑骑士",
        "Queen of Swords": "宝剑皇后",
        "King of Swords": "宝剑国王",
        // Minor Arcana - Pentacles (星币)
        "Ace of Pentacles": "星币王牌",
        "Two of Pentacles": "星币二",
        "Three of Pentacles": "星币三",
        "Four of Pentacles": "星币四",
        "Five of Pentacles": "星币五",
        "Six of Pentacles": "星币六",
        "Seven of Pentacles": "星币七",
        "Eight of Pentacles": "星币八",
        "Nine of Pentacles": "星币九",
        "Ten of Pentacles": "星币十",
        "Page of Pentacles": "星币侍从",
        "Knight of Pentacles": "星币骑士",
        "Queen of Pentacles": "星币皇后",
        "King of Pentacles": "星币国王"
    };

    const SUITS = ['Wands', 'Cups', 'Swords', 'Pentacles'];
    const RANKS = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Page', 'Knight', 'Queen', 'King'];
    
    // Tarot card interpretations (正位 and 逆位)
    const CARD_INTERPRETATIONS = {
        // Major Arcana
        "The Fool": { upright: "新的开始，冒险精神，纯真与自由。踏上未知的旅程，拥抱无限可能。", reversed: "鲁莽冲动，缺乏计划，过度冒险。需要谨慎思考，避免不必要的风险。" },
        "The Magician": { upright: "意志力与行动力，将想法转化为现实。拥有实现目标所需的所有工具。", reversed: "缺乏方向，意志薄弱，资源浪费。需要重新聚焦，明确目标。" },
        "The High Priestess": { upright: "直觉与潜意识，内在智慧。倾听内心的声音，相信直觉的指引。", reversed: "忽视直觉，缺乏内在连接。需要静心思考，重新连接内在智慧。" },
        "The Empress": { upright: "丰饶与母性，创造力与自然。享受生活的美好，孕育新的想法。", reversed: "创造力受阻，过度依赖。需要平衡给予与接受，重新连接自然。" },
        "The Emperor": { upright: "权威与结构，稳定与秩序。建立坚实的基础，展现领导力。", reversed: "控制欲过强，缺乏灵活性。需要学会平衡，适度放松控制。" },
        "The Hierophant": { upright: "传统与精神指导，寻求意义。遵循传统智慧，寻找精神导师。", reversed: "反叛传统，质疑权威。需要找到自己的道路，不盲从。" },
        "The Lovers": { upright: "爱情与选择，价值观的体现。做出重要的选择，追求真爱。", reversed: "关系失衡，错误的选择。需要重新评估关系，做出明智决定。" },
        "The Chariot": { upright: "意志与胜利，克服障碍。保持专注，朝着目标前进。", reversed: "缺乏方向，失去控制。需要重新聚焦，恢复平衡。" },
        "Strength": { upright: "内在力量，耐心与同情。以柔克刚，展现真正的力量。", reversed: "力量滥用，缺乏耐心。需要控制情绪，展现真正的力量。" },
        "The Hermit": { upright: "内省与寻求真理，精神指引。独自思考，寻找内在答案。", reversed: "孤立与孤独，过度内省。需要与他人连接，寻求帮助。" },
        "Wheel of Fortune": { upright: "命运之轮转动，变化与周期。接受生活的起伏，把握机遇。", reversed: "坏运气，抗拒变化。需要接受变化，调整心态。" },
        "Justice": { upright: "公平与平衡，因果报应。做出公正的决定，承担责任。", reversed: "不公正，缺乏责任感。需要面对真相，承担责任。" },
        "The Hanged Man": { upright: "暂停与牺牲，新的视角。放下执念，获得新的理解。", reversed: "拖延与抗拒，不愿改变。需要采取行动，接受改变。" },
        "Death": { upright: "结束与转变，新的开始。放下过去，迎接新的阶段。", reversed: "抗拒改变，停滞不前。需要接受结束，拥抱新的开始。" },
        "Temperance": { upright: "平衡与调和，耐心与节制。找到平衡，融合对立面。", reversed: "失衡与极端，缺乏耐心。需要寻找平衡，避免极端。" },
        "The Devil": { upright: "束缚与诱惑，物质欲望。认清束缚，寻求自由。", reversed: "摆脱束缚，重获自由。打破枷锁，追求真正的自由。" },
        "The Tower": { upright: "突然的变化，启示与觉醒。旧的结构崩塌，新的开始。", reversed: "抗拒变化，压抑情绪。需要接受变化，释放情绪。" },
        "The Star": { upright: "希望与灵感，精神指引。保持希望，相信未来。", reversed: "失去希望，缺乏灵感。需要重新点燃希望，寻找灵感。" },
        "The Moon": { upright: "幻觉与恐惧，潜意识。面对恐惧，探索未知。", reversed: "释放恐惧，清晰思考。克服幻觉，获得清晰。" },
        "The Sun": { upright: "快乐与成功，活力与乐观。享受成功，保持积极。", reversed: "过度乐观，缺乏现实感。需要保持平衡，面对现实。" },
        "Judgement": { upright: "反思与重生，新的开始。评估过去，准备重生。", reversed: "缺乏自我反省，拒绝改变。需要自我评估，接受改变。" },
        "The World": { upright: "完成与成就，圆满与整合。达成目标，享受成功。", reversed: "未完成，缺乏成就感。需要完成未竟之事，追求圆满。" },
        
        // Minor Arcana - Wands (权杖)
        "Ace of Wands": { upright: "新的创意项目，灵感与热情。开始新的冒险，点燃激情。", reversed: "缺乏灵感，创意受阻。需要重新点燃热情，寻找新的方向。" },
        "Two of Wands": { upright: "规划未来，个人力量。制定计划，准备行动。", reversed: "缺乏计划，优柔寡断。需要做出决定，采取行动。" },
        "Three of Wands": { upright: "探索与扩张，远见。展望未来，扩大视野。", reversed: "视野狭窄，缺乏远见。需要开阔视野，考虑长远。" },
        "Four of Wands": { upright: "庆祝与和谐，稳定。享受成功，庆祝成就。", reversed: "缺乏稳定，关系紧张。需要寻找平衡，修复关系。" },
        "Five of Wands": { upright: "竞争与冲突，挑战。面对竞争，展现能力。", reversed: "避免冲突，缺乏竞争。需要面对挑战，积极参与。" },
        "Six of Wands": { upright: "胜利与成功，公众认可。获得成功，享受荣誉。", reversed: "缺乏认可，自我怀疑。需要相信自己，坚持努力。" },
        "Seven of Wands": { upright: "坚持立场，捍卫信念。保护自己的立场，坚持原则。", reversed: "放弃立场，缺乏自信。需要坚持信念，展现勇气。" },
        "Eight of Wands": { upright: "快速行动，进展迅速。迅速行动，把握时机。", reversed: "延迟与阻碍，缺乏进展。需要克服障碍，加快步伐。" },
        "Nine of Wands": { upright: "坚韧与毅力，最后的努力。坚持到底，不轻言放弃。", reversed: "精疲力尽，缺乏韧性。需要休息恢复，重新振作。" },
        "Ten of Wands": { upright: "负担过重，责任压力。承担过多，需要减轻负担。", reversed: "摆脱负担，重新分配。需要放下不必要的责任。" },
        "Page of Wands": { upright: "探索精神，新的开始。保持好奇心，探索新领域。", reversed: "缺乏热情，拖延行动。需要重新点燃热情，采取行动。" },
        "Knight of Wands": { upright: "行动与冒险，热情冲动。勇敢行动，追求目标。", reversed: "冲动鲁莽，缺乏耐心。需要冷静思考，制定计划。" },
        "Queen of Wands": { upright: "自信与魅力，热情领导。展现自信，发挥领导力。", reversed: "缺乏自信，情绪低落。需要重建自信，展现魅力。" },
        "King of Wands": { upright: "自然领导力，远见与热情。发挥领导力，激励他人。", reversed: "专制独裁，缺乏远见。需要平衡领导风格，倾听他人。" },
        
        // Minor Arcana - Cups (圣杯)
        "Ace of Cups": { upright: "新的情感，爱与直觉。开启新的情感体验，感受爱意。", reversed: "情感封闭，缺乏连接。需要打开心扉，接受情感。" },
        "Two of Cups": { upright: "伙伴关系，相互吸引。建立深厚关系，相互支持。", reversed: "关系破裂，缺乏连接。需要修复关系，重新建立连接。" },
        "Three of Cups": { upright: "友谊与庆祝，社交快乐。享受友谊，庆祝成功。", reversed: "社交孤立，关系紧张。需要修复关系，重新连接。" },
        "Four of Cups": { upright: "情感冷漠，错过机会。需要重新审视，把握机会。", reversed: "重新参与，新的机会。抓住新机会，积极参与。" },
        "Five of Cups": { upright: "失落与悲伤，关注损失。需要接受失落，寻找希望。", reversed: "接受失落，寻找希望。放下过去，向前看。" },
        "Six of Cups": { upright: "怀旧与回忆，纯真快乐。回忆过去，感受纯真。", reversed: "活在过去，无法前进。需要放下过去，面向未来。" },
        "Seven of Cups": { upright: "选择与幻想，多种可能。需要明确目标，做出选择。", reversed: "明确目标，做出决定。摆脱幻想，采取行动。" },
        "Eight of Cups": { upright: "放弃与离开，寻找意义。离开不满意的现状，寻找更深的意义。", reversed: "避免离开，停滞不前。需要勇敢离开，追求更好。" },
        "Nine of Cups": { upright: "满足与愿望实现，情感满足。愿望成真，享受满足。", reversed: "缺乏满足，过度追求。需要感恩现有，寻找内在满足。" },
        "Ten of Cups": { upright: "家庭和谐，情感圆满。享受家庭幸福，情感满足。", reversed: "家庭不和谐，情感缺失。需要修复关系，重建和谐。" },
        "Page of Cups": { upright: "情感消息，创意灵感。接受情感指引，发挥创意。", reversed: "情感混乱，创意受阻。需要理清情感，重新连接。" },
        "Knight of Cups": { upright: "浪漫与魅力，情感追求。追求浪漫，展现魅力。", reversed: "情感不成熟，过度理想化。需要面对现实，成熟处理情感。" },
        "Queen of Cups": { upright: "情感智慧，直觉与同情。展现情感智慧，倾听直觉。", reversed: "情感不稳定，缺乏边界。需要建立边界，稳定情绪。" },
        "King of Cups": { upright: "情感平衡，同情与支持。展现情感成熟，支持他人。", reversed: "情感失衡，情绪化。需要控制情绪，保持平衡。" },
        
        // Minor Arcana - Swords (宝剑)
        "Ace of Swords": { upright: "新的想法，清晰与真理。获得清晰洞察，追求真理。", reversed: "思维混乱，缺乏清晰。需要理清思路，寻求清晰。" },
        "Two of Swords": { upright: "困难选择，僵持状态。需要做出决定，打破僵局。", reversed: "做出决定，打破僵局。摆脱犹豫，采取行动。" },
        "Three of Swords": { upright: "心碎与悲伤，情感痛苦。接受痛苦，开始愈合。", reversed: "释放痛苦，开始愈合。放下悲伤，向前看。" },
        "Four of Swords": { upright: "休息与恢复，内心平静。需要休息，恢复精力。", reversed: "缺乏休息，精疲力尽。需要强制休息，恢复平衡。" },
        "Five of Swords": { upright: "冲突与失败，不公正胜利。需要反思行为，寻求和解。", reversed: "和解与宽恕，修复关系。放下冲突，寻求和解。" },
        "Six of Swords": { upright: "过渡与离开，寻求平静。离开困难，寻找平静。", reversed: "无法离开，停滞不前。需要勇敢离开，追求更好。" },
        "Seven of Swords": { upright: "欺骗与策略，独自行动。需要诚实，避免欺骗。", reversed: "诚实与正直，寻求帮助。展现诚实，寻求支持。" },
        "Eight of Swords": { upright: "束缚与限制，自我限制。需要打破束缚，获得自由。", reversed: "摆脱束缚，获得自由。打破限制，追求自由。" },
        "Nine of Swords": { upright: "焦虑与恐惧，噩梦困扰。需要面对恐惧，寻求帮助。", reversed: "释放恐惧，寻求帮助。克服焦虑，获得平静。" },
        "Ten of Swords": { upright: "背叛与结束，痛苦终结。接受结束，准备重生。", reversed: "恢复与重生，新的开始。从痛苦中恢复，迎接新生。" },
        "Page of Swords": { upright: "好奇心与想法，新的视角。保持好奇心，探索新想法。", reversed: "缺乏想法，思维混乱。需要理清思路，寻求清晰。" },
        "Knight of Swords": { upright: "行动与决心，快速决定。迅速行动，追求目标。", reversed: "冲动鲁莽，缺乏思考。需要冷静思考，制定计划。" },
        "Queen of Swords": { upright: "清晰思考，独立判断。展现智慧，独立判断。", reversed: "思维混乱，缺乏判断。需要理清思路，寻求清晰。" },
        "King of Swords": { upright: "智力权威，清晰沟通。展现智慧，清晰表达。", reversed: "专制独裁，缺乏同情。需要平衡理性与情感。" },
        
        // Minor Arcana - Pentacles (星币)
        "Ace of Pentacles": { upright: "新的机会，物质开始。把握新机会，开始积累。", reversed: "错失机会，缺乏资源。需要把握机会，积累资源。" },
        "Two of Pentacles": { upright: "平衡与优先，多任务处理。需要平衡，管理优先级。", reversed: "失衡与混乱，缺乏平衡。需要重新平衡，简化生活。" },
        "Three of Pentacles": { upright: "团队合作，技能与规划。展现技能，团队合作。", reversed: "缺乏合作，技能不足。需要提升技能，加强合作。" },
        "Four of Pentacles": { upright: "控制与安全，物质保守。需要适度放松，分享资源。", reversed: "释放控制，慷慨分享。放下执念，分享资源。" },
        "Five of Pentacles": { upright: "物质困难，精神孤立。需要寻求帮助，重新连接。", reversed: "恢复与连接，寻求帮助。从困难中恢复，重新连接。" },
        "Six of Pentacles": { upright: "给予与接受，慷慨与分享。展现慷慨，分享资源。", reversed: "自私与不平衡，缺乏分享。需要学会分享，平衡给予。" },
        "Seven of Pentacles": { upright: "评估与耐心，长期投资。评估进展，保持耐心。", reversed: "缺乏耐心，急于求成。需要保持耐心，长期规划。" },
        "Eight of Pentacles": { upright: "技能发展，专注与努力。专注提升，持续努力。", reversed: "缺乏技能，缺乏专注。需要提升技能，保持专注。" },
        "Nine of Pentacles": { upright: "独立与自足，物质成功。享受独立，自给自足。", reversed: "缺乏独立，过度依赖。需要培养独立，减少依赖。" },
        "Ten of Pentacles": { upright: "财富与家庭，长期安全。享受财富，家庭幸福。", reversed: "家庭冲突，财务问题。需要修复关系，管理财务。" },
        "Page of Pentacles": { upright: "学习与机会，新的技能。把握学习机会，发展新技能。", reversed: "缺乏学习，错失机会。需要积极学习，把握机会。" },
        "Knight of Pentacles": { upright: "努力与责任，稳定进展。保持努力，稳步前进。", reversed: "缺乏努力，停滞不前。需要恢复努力，继续前进。" },
        "Queen of Pentacles": { upright: "实用与关怀，物质安全。展现实用智慧，关怀他人。", reversed: "缺乏关怀，物质主义。需要平衡物质与情感。" },
        "King of Pentacles": { upright: "安全与控制，商业成功。展现商业智慧，确保安全。", reversed: "缺乏控制，财务问题。需要恢复控制，管理财务。" }
    };
    
    // Minor Arcana card images mapping
    // 使用实际的小阿卡纳牌图片文件
    const MINOR_CARD_URLS = {};
    SUITS.forEach(suit => {
        RANKS.forEach(rank => {
            const cardName = `${rank} of ${suit}`;
            // 文件名格式: Rank_of_Suit.png (例如: Ace_of_Wands.png)
            MINOR_CARD_URLS[cardName] = `${rank}_of_${suit}.png`;
        });
    });
    
    let FULL_DECK = [...MAJORS];
    SUITS.forEach(suit => {
        RANKS.forEach(rank => {
            const cardName = `${rank} of ${suit}`;
            FULL_DECK.push({
                name: cardName,
                url: MINOR_CARD_URLS[cardName]
            });
        });
    });

    const TOTAL_CARDS = 78;
    const RADIUS = 18.0; 

    const STATE = { BROWSING: 0, ANIMATING: 1, VIEWING: 2, DISSOLVING: 3 };
    let currentState = STATE.BROWSING;
    let inputMode = 'mouse';
    let galleryCards = []; 
    let activeCardMesh = null; 
    let activeCardData = null;  
    let isUpright = true;
    
    // Gallery Movement - SLOWER and HEAVIER
    let galleryOffset = 0;
    let galleryVelocity = 0; 
    const FRICTION = 0.92;   // More drag (was 0.95)
    const AUTO_ROTATION_SPEED = 0.0003; 
    
    // Animation
    let animStartTime = 0;
    let startPos = new THREE.Vector3();
    let startRot = new THREE.Quaternion();
    let targetPos = new THREE.Vector3();
    let targetRot = new THREE.Quaternion();
    
    let scene, camera, renderer, raycaster;
    let particlesSystem;
    let hoveredCard = null;
    
    const mouse = new THREE.Vector2();
    const handPointer = new THREE.Vector2();
    let isPinching = false;
    let wasPinching = false;
    let mouseClicked = false;
    
    init();

    async function init() {
        // Check if accessing via file:// protocol (not allowed due to CORS)
        if (window.location.protocol === 'file:') {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.innerHTML = `
                    <div style="text-align: center; color: #fff; padding: 20px;">
                        <h2 style="color: #ff4444;">⚠️ 错误：请通过HTTP服务器访问</h2>
                        <p>由于浏览器安全策略，不能直接打开HTML文件。</p>
                        <p>请在终端运行：<code style="background: #333; padding: 5px 10px; border-radius: 3px;">./start_server.sh</code></p>
                        <p>然后在浏览器访问：<br><code style="background: #333; padding: 5px 10px; border-radius: 3px; color: #4CAF50;">http://localhost:8000/tarot2.html</code></p>
                    </div>
                `;
            }
            console.error('请通过HTTP服务器访问，不要直接打开HTML文件！');
            console.error('运行: ./start_server.sh');
            console.error('然后访问: http://localhost:8000/tarot2.html');
            return;
        }
        
        const container = document.body;
        
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a0a, 0.015); 

        // Camera - FOV 25 for "Telephoto" look (only 5 cards visible)
        camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 0); 
        camera.lookAt(0, 0, -1);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a0a, 1); // 深色背景，配合星空效果
        container.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();

        // Lighting - Pure White, no weird colors - Increased intensity for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); 
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);
        
        // Face Light (ensures card face is bright) - Increased intensity
        const faceLight = new THREE.PointLight(0xffffff, 1.0, 20);
        faceLight.position.set(0, 0, 0);
        scene.add(faceLight);

        createStarfield();
        createDeckGallery();
        initAshSystem();

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);

        try { 
            await setupMediaPipe(); 
        } catch (e) { 
            console.warn("Camera failed", e); 
            inputMode = 'mouse';
            updateModeBtn();
        }
        
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => {
            document.getElementById('loader').remove();
            // 显示中间页面，不显示卡牌页
            const introScreen = document.getElementById('intro-screen');
            introScreen.classList.add('active');
            
            // 点击按钮后进入主界面并开始动画
            document.getElementById('intro-btn').addEventListener('click', () => {
                introScreen.style.opacity = 0;
                setTimeout(() => {
                    introScreen.remove();
                    // 开始动画循环
                    animate();
                    // 显示引导文字
                    startGuidanceCycle();
                }, 1000);
            });
        }, 800);
    }

    function createStarfield() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        // 增加星星数量，创造更密集的星空效果
        for (let i = 0; i < 8000; i++) {
            // 分布在更大的范围内，创造深度感
            vertices.push((Math.random() - 0.5) * 300);
            vertices.push((Math.random() - 0.5) * 300);
            vertices.push((Math.random() - 0.5) * 300);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        
        // 白色星星，不同大小和亮度，创造神秘氛围
        const material = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 0.12, 
            transparent: true, 
            opacity: 0.9,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending
        });
        
        const stars = new THREE.Points(geometry, material);
        stars.renderOrder = -100; // 确保星星在背景层
        scene.add(stars);
        
        // 添加一些更亮的星星（闪烁效果）
        const brightGeometry = new THREE.BufferGeometry();
        const brightVertices = [];
        for (let i = 0; i < 300; i++) {
            brightVertices.push((Math.random() - 0.5) * 300);
            brightVertices.push((Math.random() - 0.5) * 300);
            brightVertices.push((Math.random() - 0.5) * 300);
        }
        brightGeometry.setAttribute('position', new THREE.Float32BufferAttribute(brightVertices, 3));
        const brightMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 0.2, 
            transparent: true, 
            opacity: 1.0,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending
        });
        const brightStars = new THREE.Points(brightGeometry, brightMaterial);
        brightStars.renderOrder = -100; // 确保星星在背景层
        scene.add(brightStars);
        
        // 添加一些中等亮度的星星，增加层次感
        const mediumGeometry = new THREE.BufferGeometry();
        const mediumVertices = [];
        for (let i = 0; i < 1000; i++) {
            mediumVertices.push((Math.random() - 0.5) * 300);
            mediumVertices.push((Math.random() - 0.5) * 300);
            mediumVertices.push((Math.random() - 0.5) * 300);
        }
        mediumGeometry.setAttribute('position', new THREE.Float32BufferAttribute(mediumVertices, 3));
        const mediumMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 0.06, 
            transparent: true, 
            opacity: 0.6,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending
        });
        const mediumStars = new THREE.Points(mediumGeometry, mediumMaterial);
        mediumStars.renderOrder = -100; // 确保星星在背景层
        scene.add(mediumStars);
    }

    function createDeckGallery() {
        galleryCards.forEach(c => scene.remove(c));
        galleryCards = [];

        // Visual: Rounded Box, 30 degree feel -> approx 0.1 radius on 1.2 width
        const geometry = new RoundedBoxGeometry(1.2, 2.0, 0.02, 4, 0.1); 
        
        // Materials: Pure Physical Matte (StandardMaterial)
        // 0-3: Sides (Dark)
        const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
        // 4: Back (+Z) - Dark gray matte physical material, no texture, no glow
        const backMat = new THREE.MeshStandardMaterial({ 
            color: 0x333333, // Dark gray
            roughness: 0.9, // Matte finish
            metalness: 0.0,
            emissive: 0x000000, // No glow
            transparent: false,
            opacity: 1.0
        });
        // 5: Front (-Z) - White base for texture - Use DoubleSide to ensure visibility
        const frontMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.0,
            metalness: 0.0,
            emissive: 0x000000, // No emissive glow
            side: THREE.DoubleSide, // Double side to ensure visibility from any angle
            transparent: false,
            opacity: 1.0,
            depthWrite: true,
            depthTest: true
        });

        const materials = [sideMat, sideMat, sideMat, sideMat, backMat, frontMat];

        for (let i = 0; i < TOTAL_CARDS; i++) {
            // Clone all materials to ensure each card has its own material instances
            // This ensures all cards have the same back material appearance
            const myMats = materials.map(mat => mat.clone());

            const card = new THREE.Mesh(geometry, myMats);
            card.userData = { id: i, isGallery: true };
            card.renderOrder = 0; // 卡牌在前景层，在星星之上
            
            scene.add(card);
            galleryCards.push(card);
        }
    }

    function updateGalleryLayout(dt) {
        // Always update layout to fill gaps, but only update offset when browsing
        const isBrowsing = (currentState === STATE.BROWSING);
        const isDissolving = (currentState === STATE.DISSOLVING);
        const isAnimating = (currentState === STATE.ANIMATING);
        const isViewing = (currentState === STATE.VIEWING);
        
        // Count visible cards (excluding activeCardMesh which is being drawn/removed)
        // This count decreases by 1 each time a card is removed, ensuring no gaps
        const visibleCount = galleryCards.filter(card => card.visible && card !== activeCardMesh).length;
        
        // If no visible cards, return early
        if (visibleCount === 0) return;
        
        // Calculate angle step based on current visible card count
        // When a card is removed, visibleCount decreases by 1, angleStep increases, ensuring no gaps
        const TWO_PI = Math.PI * 2;
        const angleStep = TWO_PI / visibleCount;

        // Only update galleryOffset when browsing (keep it frozen during other states to prevent cards from returning)
        if (isBrowsing) {
            // Always update offset when browsing to allow rotation
        galleryOffset += (galleryVelocity + AUTO_ROTATION_SPEED) * dt;
        galleryVelocity *= FRICTION;

            // Keep galleryOffset in range [0, 2π) for seamless looping
            galleryOffset = ((galleryOffset % TWO_PI) + TWO_PI) % TWO_PI;
        }
        // During animating, viewing, and dissolving, galleryOffset stays frozen at its current value

        // Update positions: right-side cards fill gaps from the left
        // Each visible card occupies position index = visibleIndex (0, 1, 2, ..., visibleCount-1)
        // When a card is removed, all subsequent cards shift left by 1 position, ensuring no gaps
        let visibleIndex = 0; // Track position in the visible sequence (0 to visibleCount-1)
        galleryCards.forEach((mesh, originalIndex) => {
            // Skip invisible cards and the active card being drawn (to prevent it from returning to original position)
            if (!mesh.visible || mesh === activeCardMesh) return;
            
            // Calculate new position: each visible card occupies position = visibleIndex
            // When visibleCount decreases by 1, angleStep increases, and cards automatically fill gaps
            const angle = (visibleIndex * angleStep) + galleryOffset;
            const xPos = Math.sin(angle) * RADIUS;
            const zPos = -Math.cos(angle) * RADIUS;
            let yPos = 0;

            // Simple Hover Logic (only when browsing)
            // Show hover effect for hovered card with soft glow outline
            if (isBrowsing && hoveredCard === mesh) {
                yPos += 0.3;
                const pullIn = 2.0; 
                mesh.position.set(
                    xPos * (1 - pullIn/RADIUS), 
                    yPos, 
                    zPos * (1 - pullIn/RADIUS)
                );
                mesh.scale.setScalar(1.1);
                
                // IMPORTANT: Rotate card to face camera (front-facing)
                // Make the card look directly at the camera position (0, 0, 0)
                mesh.lookAt(camera.position);
                
                // Add soft glow outline effect with smooth transition
                // Use emissive property for all materials to create outline glow
                const targetEmissive = 0xffffff; // White glow
                const emissiveIntensity = 0.15; // Soft glow intensity
                
                // Smoothly transition emissive for all materials
                for (let i = 0; i < mesh.material.length; i++) {
                    if (mesh.material[i]) {
                        const currentEmissive = mesh.material[i].emissive;
                        const targetEmissiveColor = new THREE.Color(targetEmissive);
                        targetEmissiveColor.multiplyScalar(emissiveIntensity);
                        
                        // Smooth lerp transition (0.1 = smooth, 0.3 = faster)
                        currentEmissive.lerp(targetEmissiveColor, 0.15);
                        mesh.material[i].needsUpdate = true;
                    }
                }
            } else {
                // Remove glow effect with smooth transition when not hovered
                for (let i = 0; i < mesh.material.length; i++) {
                    if (mesh.material[i]) {
                        const currentEmissive = mesh.material[i].emissive;
                        const targetEmissiveColor = new THREE.Color(0x000000); // No glow
                        
                        // Smooth lerp transition back to no glow
                        currentEmissive.lerp(targetEmissiveColor, 0.15);
                        mesh.material[i].needsUpdate = true;
                    }
                }
                // During animating/viewing/dissolving, directly set position to prevent cards from returning
                // During browsing, also directly set position to ensure no gaps during rotation
                if (isBrowsing || isAnimating || isViewing || isDissolving) {
                    // Directly set position to ensure no gaps and prevent position drift
                mesh.position.set(xPos, yPos, zPos);
                } else {
                    // For other states, use normal smooth transition
                    mesh.position.lerp(new THREE.Vector3(xPos, yPos, zPos), 0.15);
                }
                mesh.scale.setScalar(1.0);
            }
            
            // Look at Center. +Z (Back) faces Camera (0,0,0)
            mesh.lookAt(0, 0, 0);
            
            visibleIndex++; // Move to next position (0, 1, 2, ..., visibleCount-1)
        });
    }

    function handleInputScroll(pointerX) {
        if (currentState !== STATE.BROWSING) return;
        const deadzone = 0.2;
        if (Math.abs(pointerX) > deadzone) {
            const dir = pointerX > 0 ? -1 : 1;
            // Drastically reduced strength for "Heavy" feel
            const strength = (Math.abs(pointerX) - deadzone) * 0.05; 
            galleryVelocity += dir * strength;
        }
    }

    function attemptDraw(mesh) {
        if (!mesh) return;
        
        // Mark card as invisible instead of removing from array to maintain seamless loop
        mesh.visible = false;
        
        // Pick Random
        const randId = Math.floor(Math.random() * FULL_DECK.length);
        activeCardData = FULL_DECK[randId];
        isUpright = Math.random() > 0.5;

        activeCardMesh = mesh;
        // Change state to ANIMATING BEFORE updating layout to freeze galleryOffset
        currentState = STATE.ANIMATING;
        // IMPORTANT: Keep wasPinching = true when starting animation if user was pinching
        // This allows us to detect release in VIEWING state
        // Don't reset wasPinching here - preserve the pinching state
        // Force immediate layout update to fill the gap (now with frozen galleryOffset)
        updateGalleryLayout(0);
        animStartTime = Date.now();
        
        // 记录抽取时间，用于显示"松开手指"提示
        cardDrawTime = Date.now();
        showReleaseGuidance();
        startPos.copy(mesh.position);
        startRot.copy(mesh.quaternion);
        
        // Target: Center (FOV 25 means we push Z back to -8 to fit screen)
        targetPos.set(0, 0, -8.0); 
        
        // Calculate final rotation: face camera
        const m = new THREE.Matrix4();
        m.lookAt(camera.position, targetPos, new THREE.Vector3(0,1,0));
        const lookQ = new THREE.Quaternion().setFromRotationMatrix(m);
        targetRot.copy(lookQ);

        // Load Texture immediately and ensure front face is visible
        const loader = new THREE.TextureLoader();
        
        // Set all materials to be visible and opaque
        // Initially show back face, will flip to front face during animation
        for (let i = 0; i < activeCardMesh.material.length; i++) {
            if (activeCardMesh.material[i]) {
                if (i === 4) {
                    // Back face - show initially (will hide after flip)
                    activeCardMesh.material[i].visible = true;
                } else if (i === 5) {
                    // Front face - hide initially (will show after flip)
                    activeCardMesh.material[i].visible = false;
                } else {
                    // Side faces - keep visible
                    activeCardMesh.material[i].visible = true;
                }
                activeCardMesh.material[i].transparent = false;
                activeCardMesh.material[i].opacity = 1.0;
                activeCardMesh.material[i].depthWrite = true;
                activeCardMesh.material[i].depthTest = true;
            }
        }
        
        // Ensure material is properly configured before loading texture
        const frontMaterial = activeCardMesh.material[5];
        // Don't set visible to true here - it will be shown during flip animation
        frontMaterial.side = THREE.DoubleSide; // Use double side to ensure visibility
        frontMaterial.color.setHex(0xffffff);
        frontMaterial.emissive.setHex(0x000000); // No emissive glow
        frontMaterial.roughness = 0.4; // Normal roughness
        frontMaterial.metalness = 0.0;
        frontMaterial.transparent = false;
        frontMaterial.opacity = 1.0;
        frontMaterial.depthWrite = true;
        frontMaterial.depthTest = true;
        frontMaterial.map = null; // Clear any existing texture
        frontMaterial.needsUpdate = true;
        
        // Ensure mesh is visible and render on top
        activeCardMesh.visible = true;
        activeCardMesh.renderOrder = 999; // Render on top
        activeCardMesh.layers.set(0); // Ensure on default layer
        
        // Ensure we're using the correct path - check if we're on http/https
        const isLocalFile = window.location.protocol === 'file:';
        if (isLocalFile) {
            console.error('错误：请通过HTTP服务器访问，不要直接打开HTML文件！');
            console.error('请访问: http://localhost:8000/tarot2.html');
            updateStatus('错误：请通过HTTP服务器访问');
            return;
        }
        
        const imageUrl = BASE_URL + activeCardData.url;
        console.log('Loading texture:', imageUrl, 'isUpright:', isUpright);
        loader.load(imageUrl, (tex) => {
            if (!activeCardMesh) {
                console.warn('activeCardMesh is null, cannot apply texture');
                return;
            }
            tex.colorSpace = THREE.SRGBColorSpace;
            // For reversed cards, flip texture vertically to show reversed card
            // In Three.js, flipY=true is the default (texture is flipped to match OpenGL convention)
            // For upright cards (正位): flipY = true (normal orientation after OpenGL flip)
            // For reversed cards (逆位): flipY = false (flip the texture vertically to show reversed)
            // Note: The actual behavior depends on how the source image is oriented
            // If the image shows upright card normally, then:
            //   - Upright: flipY = true (show as-is after OpenGL convention flip)
            //   - Reversed: flipY = false (flip vertically to show reversed)
            tex.flipY = isUpright; // true for upright, false for reversed
            tex.needsUpdate = true; // Ensure texture updates with new flipY value
            console.log('Texture loaded - isUpright:', isUpright, 'flipY:', tex.flipY);
            // Using Standard Material with full white color + texture
            frontMaterial.map = tex;
            // Ensure flipY is still set after assigning to material (double-check)
            if (frontMaterial.map) {
                frontMaterial.map.flipY = isUpright;
                frontMaterial.map.needsUpdate = true;
            }
            // Force material to be ready and visible when texture loads
            frontMaterial.visible = false; // Will be shown during flip animation
            frontMaterial.needsUpdate = true;
            frontMaterial.side = THREE.DoubleSide; // Use double side to ensure visibility
            frontMaterial.color.setHex(0xffffff);
            frontMaterial.emissive.setHex(0x000000); // No emissive glow
            frontMaterial.roughness = 0.4; // Normal roughness
            frontMaterial.transparent = false;
            frontMaterial.opacity = 1.0;
            frontMaterial.depthWrite = true;
            frontMaterial.depthTest = true;
            // Don't set visible here - it will be controlled by flip animation
            // The material will be made visible when flip reaches 90 degrees
            frontMaterial.needsUpdate = true;
            
            // Force render update
            if (renderer) renderer.render(scene, camera);
            console.log('Texture loaded successfully:', imageUrl);
        }, undefined, (err) => {
            console.error('Failed to load texture:', imageUrl, err);
            // Fallback: keep white material visible even without texture
            frontMaterial.side = THREE.DoubleSide; // Use double side to ensure visibility
            frontMaterial.color.setHex(0xffffff);
            frontMaterial.emissive.setHex(0x000000); // No emissive glow
            frontMaterial.transparent = false;
            frontMaterial.opacity = 1.0;
            frontMaterial.depthWrite = true;
            frontMaterial.depthTest = true;
            // Don't set visible here - it will be controlled by flip animation
            frontMaterial.needsUpdate = true;
            activeCardMesh.visible = true;
            activeCardMesh.renderOrder = 999;
            activeCardMesh.layers.set(0);
            console.log('Using fallback white material');
        });

        mouseClicked = false;
        updateCardInfo(activeCardData.name, isUpright);
    }

    function updateActiveCardInteraction(dt) {
        if (!activeCardMesh) return;

        if (currentState === STATE.ANIMATING) {
            const now = Date.now();
            const duration = 1400; // 1.4s flight (slower for better flip animation)
            const progress = Math.min((now - animStartTime) / duration, 1);
            const ease = 1 - Math.pow(1 - progress, 3);

            // Interpolate position (move up and forward)
            activeCardMesh.position.lerpVectors(startPos, targetPos, ease);
            
            // Rotation animation: 
            // Phase 1 (0-20%): Float out with back face showing
            // Phase 2 (20-100%): Single right turn flip from back to front (around Y axis, negative angle)
            
            if (progress < 0.2) {
                // Phase 1: Just float out, keep back face showing
                activeCardMesh.quaternion.copy(startRot);
                // Show back face, hide front face
                if (activeCardMesh.material[4]) activeCardMesh.material[4].visible = true;
                if (activeCardMesh.material[5]) activeCardMesh.material[5].visible = false;
            } else {
                // Phase 2: Single right turn flip from back to front (around Y axis, negative angle)
                const flipProgress = (progress - 0.2) / 0.8; // 0 to 1
                const flipEase = 1 - Math.pow(1 - flipProgress, 2); // Slower easing for smoother flip
                const flipAngle = -Math.PI * flipEase; // 0 to -PI (right turn, 180 degrees)
                
                // Single right turn: from back to front (around Y axis, negative angle)
                const flipQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), flipAngle);
                activeCardMesh.quaternion.copy(startRot.clone().multiply(flipQ));
                
                // Switch materials when halfway through flip (90 degrees = PI/2)
                // Make sure front material is visible and properly configured
                if (Math.abs(flipAngle) > Math.PI / 2) {
                    if (activeCardMesh.material[4]) {
                        activeCardMesh.material[4].visible = false;
                        activeCardMesh.material[4].needsUpdate = true;
                    }
                    if (activeCardMesh.material[5]) {
                        activeCardMesh.material[5].visible = true;
                        // Ensure front material is properly configured when it becomes visible
                        if (activeCardMesh.material[5].map) {
                            activeCardMesh.material[5].map.needsUpdate = true;
                        }
                        activeCardMesh.material[5].needsUpdate = true;
                    }
                }
            }

            if (progress >= 1) {
                // Ensure front face is visible and properly configured when animation completes
                if (activeCardMesh.material[4]) {
                    activeCardMesh.material[4].visible = false;
                    activeCardMesh.material[4].needsUpdate = true;
                }
                if (activeCardMesh.material[5]) {
                    activeCardMesh.material[5].visible = true;
                    // Ensure texture is properly configured
                    if (activeCardMesh.material[5].map) {
                        activeCardMesh.material[5].map.needsUpdate = true;
                    }
                    activeCardMesh.material[5].needsUpdate = true;
                }
                // Hide side materials to ensure only front face is visible
                for (let i = 0; i < 4; i++) {
                    if (activeCardMesh.material[i]) {
                        activeCardMesh.material[i].visible = false;
                        activeCardMesh.material[i].needsUpdate = true;
                    }
                }
                currentState = STATE.VIEWING;
                mouseClicked = false;
                // IMPORTANT: Save the pinching state when entering VIEWING
                // We need to know if user was pinching when card was drawn
                // Don't reset wasPinching here - we need it to detect release
                if (inputMode === 'hand') {
                    // Keep wasPinching = true if user was pinching when entering VIEWING
                    // This allows us to detect when they release (wasPinching=true, isPinching=false)
                    // Only reset if they're not currently pinching
                    if (!isPinching) {
                        wasPinching = false; // User wasn't pinching, so no release to detect
                    }
                    // If isPinching is true, keep wasPinching = true so we can detect release
                }
            }
        }
        else if (currentState === STATE.VIEWING) {
            // Hover
            activeCardMesh.position.y = targetPos.y + Math.sin(Date.now() * 0.002) * 0.05;

            let confirm = false;
            if (inputMode === 'mouse') {
                if (mouseClicked) { 
                    confirm = true; 
                    mouseClicked = false; 
                }
            } else {
                // For hand mode: detect pinch release (transition from pinching to not-pinching)
                // Release pinch to trigger particle dissipation
                // Only trigger if we were pinching and now are not pinching
                // IMPORTANT: Must be in VIEWING state and user must have been pinching
                if (currentState === STATE.VIEWING && !isPinching && wasPinching) {
                    console.log('Hand gesture detected in VIEWING state: pinch released, triggering dissipation', 'isPinching:', isPinching, 'wasPinching:', wasPinching);
                    confirm = true;
                    // Reset wasPinching after confirming to prevent multiple triggers
                    wasPinching = false;
                }
            }

            if (confirm) {
                currentState = STATE.DISSOLVING;
                triggerAshEffect();
            }
        }
    }

    function triggerAshEffect() {
        if (!activeCardMesh) return;
        updateStatus("");
        updateCardInfo("", true, "");
        
        // Ensure layout is updated immediately when card is removed
        // This makes right-side cards fill gaps from the left during particle effect
        updateGalleryLayout(0);

        const center = activeCardMesh.position.clone();
        
        const geom = particlesSystem.geometry;
        const count = geom.attributes.position.count;
        const posAttr = geom.attributes.position;
        const lifes = geom.userData.lifes;
        const colors = geom.attributes.color;

        let spawned = 0;
        for(let i=0; i<count; i++) {
            if (lifes[i] <= 0 && spawned < 1200) {
                lifes[i] = 1.0;
                posAttr.setXYZ(i, center.x + (Math.random()-0.5)*0.8, center.y + (Math.random()-0.5)*1.2, center.z);
                colors.setXYZ(i, 0.9, 0.9, 0.9);
                spawned++;
            }
        }
        geom.attributes.position.needsUpdate = true;
        geom.attributes.color.needsUpdate = true;

        scene.remove(activeCardMesh);
        activeCardMesh = null;

        setTimeout(() => {
            addCardToBottomBar(activeCardData, isUpright);
            // Force layout update multiple times to ensure cards are fully in correct positions
            // Directly set positions instead of lerp to ensure they're stable
            const visibleCount = galleryCards.filter(card => card.visible).length;
            if (visibleCount > 0) {
                const TWO_PI = Math.PI * 2;
                const angleStep = TWO_PI / visibleCount;
                let visibleIndex = 0;
                galleryCards.forEach((mesh) => {
                    if (!mesh.visible) return;
                    const angle = (visibleIndex * angleStep) + galleryOffset;
                    const xPos = Math.sin(angle) * RADIUS;
                    const zPos = -Math.cos(angle) * RADIUS;
                    mesh.position.set(xPos, 0, zPos);
                    mesh.lookAt(0, 0, 0);
                    visibleIndex++;
                });
            }
            currentState = STATE.BROWSING;
            hoveredCard = null;
            // Reset velocity to prevent sudden movement when returning to browsing
            galleryVelocity = 0;
            // 粒子消散后重新开始引导循环
            startGuidanceCycle();
            // Reset pinch state when returning to browsing
            if (inputMode === 'hand') {
                wasPinching = false;
                isPinching = false;
            }
        }, 800);
    }

    function addCardToBottomBar(data, upright) {
        const bar = document.getElementById('drawn-cards-bar');
        if (!bar) {
            console.error('drawn-cards-bar not found');
            return;
        }
        
        const el = document.createElement('div');
        el.className = 'drawn-card';
        
        // Set background image first
        const imageUrl = BASE_URL + data.url;
        el.style.backgroundImage = `url("${imageUrl}")`;
        el.style.backgroundColor = 'transparent';
        
        // Add reversed class for rotation
        if (!upright) {
            el.classList.add('reversed');
            el.style.animation = 'slideUpFadeReversed 0.6s forwards';
        }
        
        bar.appendChild(el);
        
        // Debug: log the image URL
        console.log('Added card to bar:', data.name, 'Image URL:', imageUrl, 'Upright:', upright);
    }

    function initAshSystem() {
        const pCount = 5000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(pCount * 3);
        const colors = new Float32Array(pCount * 3);
        const lifes = new Float32Array(pCount);
        const velocities = new Float32Array(pCount * 3);
        for(let i=0; i<pCount; i++) { lifes[i] = 0; positions[i*3+1] = -500; }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData = { lifes, velocities };
        
        for(let i=0; i<pCount; i++) {
            velocities[i*3] = (Math.random()-0.5) * 0.05;
            velocities[i*3+1] = (Math.random()-0.5) * 0.05;
            velocities[i*3+2] = (Math.random()-0.5) * 0.05;
        }

        const material = new THREE.PointsMaterial({ size: 0.04, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false });
        particlesSystem = new THREE.Points(geometry, material);
        particlesSystem.frustumCulled = false;
        scene.add(particlesSystem);
    }

    function updateParticles() {
        const geom = particlesSystem.geometry;
        const count = geom.attributes.position.count;
        const posAttr = geom.attributes.position;
        const lifes = geom.userData.lifes;
        const vels = geom.userData.velocities;
        for(let i=0; i<count; i++) {
            if (lifes[i] > 0) {
                lifes[i] -= 0.02;
                let x = posAttr.getX(i); let y = posAttr.getY(i); let z = posAttr.getZ(i);
                x += vels[i*3]; y += vels[i*3+1]; z += vels[i*3+2];
                posAttr.setXYZ(i, x, y, z);
            } else { posAttr.setXYZ(i, 0, -500, 0); }
        }
        posAttr.needsUpdate = true;
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();

        const ptr = inputMode === 'hand' ? handPointer : mouse;
        
        // Always update gallery layout to fill gaps when cards are removed
        // But only handle input scroll when browsing
        if (currentState === STATE.BROWSING) {
            handleInputScroll(ptr.x);
        }
            updateGalleryLayout(dt);
            
        if (currentState === STATE.BROWSING) {
            // Use raycasting to detect card selection
            // Check if pointer is within card's width range (including above and below the card)
            raycaster.setFromCamera(ptr, camera);
            const intersects = raycaster.intersectObjects(galleryCards);
            
            // Update hand position indicator
            const handIndicator = document.getElementById('hand-position-indicator');
            if (handIndicator && inputMode === 'hand') {
                // Convert pointer Y from [-1, 1] to screen coordinates
                const screenY = ((1 - ptr.y) / 2) * window.innerHeight;
                const screenX = ((ptr.x + 1) / 2) * window.innerWidth;
                handIndicator.style.left = screenX + 'px';
                handIndicator.style.top = screenY + 'px';
                
                // Check if hand is detected (handPointer is not at origin)
                const handDetected = Math.abs(handPointer.x) > 0.01 || Math.abs(handPointer.y) > 0.01;
                
                // Show indicator - dim if no hand detected, bright if hand detected
                handIndicator.style.opacity = handDetected ? '1' : '0.3';
                
                // Make indicator pulse when pinching
                if (isPinching) {
                    handIndicator.style.transform = 'translate(-50%, -50%) scale(1.5)';
                    handIndicator.style.borderColor = 'rgba(0,255,0,0.8)';
                    handIndicator.style.boxShadow = '0 0 20px rgba(0,255,0,0.5)';
                } else {
                    handIndicator.style.transform = 'translate(-50%, -50%) scale(1)';
                    // Red border if no hand detected, white if hand detected
                    handIndicator.style.borderColor = handDetected ? 'rgba(255,255,255,0.6)' : 'rgba(255,0,0,0.4)';
                    handIndicator.style.boxShadow = handDetected ? '0 0 10px rgba(255,255,255,0.3)' : '0 0 10px rgba(255,0,0,0.2)';
                }
            } else if (handIndicator) {
                handIndicator.style.opacity = '0';
            }
            
            // Hide zone indicator (not used anymore)
            const zoneIndicator = document.getElementById('zone-indicator');
            if (zoneIndicator) zoneIndicator.style.opacity = '0';
            
            let hit = null;
            
            if (intersects.length > 0) {
                // Check if pointer is within card's width range
                // Card dimensions: width = 1.2, height = 2.0
                // We need to check if the intersection point is within the card's bounds
                const intersection = intersects[0];
                const cardMesh = intersection.object;
                const point = intersection.point;
                
                // Get card's local coordinate system
                const cardPosition = cardMesh.position;
                
                // Calculate distance from card center to intersection point
                const toPoint = point.clone().sub(cardPosition);
                
                // Get card's local axes
                const cardRight = new THREE.Vector3(1, 0, 0).applyQuaternion(cardMesh.quaternion);
                const cardUp = new THREE.Vector3(0, 1, 0).applyQuaternion(cardMesh.quaternion);
                
                // Calculate distances along card's width and height
                const widthDist = Math.abs(toPoint.dot(cardRight));
                const heightDist = Math.abs(toPoint.dot(cardUp));
                
                // Card dimensions: width = 1.2, height = 2.0
                // Allow selection if within card width (including above and below)
                const cardWidth = 1.2;
                const cardHeight = 2.0;
                
                // Check if pointer is within card's width range
                // Allow some tolerance for easier selection
                if (widthDist <= cardWidth / 2 + 0.1) {
                    // Within card width, check if within reasonable height range
                    // Allow selection even if slightly above or below the card
                    if (heightDist <= cardHeight / 2 + 0.5) {
                        hit = cardMesh;
                    }
                }
            }
            
            if (hit) {
                if (hoveredCard !== hit) {
                    hoveredCard = hit;
                    document.body.style.cursor = 'pointer';
                }
                
                if (inputMode === 'hand') {
                    // Hand mode gesture logic:
                    // 1. Hand open: hover/select card (just show hover effect)
                    // 2. Pinch: immediately select and draw card (trigger animation)
                    // 3. Release pinch (in VIEWING state): trigger particle dissipation
                    
                    // Only trigger if we're actually pinching AND just started pinching
                    if (isPinching && !wasPinching && currentState === STATE.BROWSING) {
                        // Just started pinching: immediately draw the card at current hand position
                        console.log('Hand gesture: pinch start, drawing card ID:', hit.userData.id, 'isPinching:', isPinching, 'wasPinching:', wasPinching);
                        // Make sure we're using the correct card (hit) for the current hand position
                        if (hit && hit.visible && hit !== activeCardMesh) {
                            attemptDraw(hit);
                        }
                    }
                } else {
                    // Mouse mode: click to select
                    if (mouseClicked) { 
                        console.log('Mouse click detected, selecting card ID:', hit.userData.id);
                        attemptDraw(hit); 
                        mouseClicked = false; 
                    }
                }
            } else {
                hoveredCard = null;
                document.body.style.cursor = 'default';
                if(mouseClicked) mouseClicked = false;
            }
        } else {
            // Hide zone indicator when not browsing
            const zoneIndicator = document.getElementById('zone-indicator');
            if (zoneIndicator) zoneIndicator.style.opacity = '0';
            // Hide hand position indicator when not browsing
            const handIndicator = document.getElementById('hand-position-indicator');
            if (handIndicator) handIndicator.style.opacity = '0';
            updateActiveCardInteraction(dt);
        }

        wasPinching = isPinching;
        updateParticles();
        renderer.render(scene, camera);
    }

    function onMouseMove(event) {
        if (inputMode !== 'mouse') return;
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }
    
    function onMouseDown() { if (inputMode === 'mouse') isPinching = true; }
    function onMouseUp() { 
        if (inputMode === 'mouse') { isPinching = false; mouseClicked = true; } 
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    async function setupMediaPipe() {
        try {
            const video = document.getElementById('input-video');
            if (!video) {
                console.error('Video element not found');
                throw new Error('Video element not found');
            }
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            // Lower thresholds for better hand detection
            hands.setOptions({ 
                maxNumHands: 1, 
                modelComplexity: 1, 
                minDetectionConfidence: 0.3, 
                minTrackingConfidence: 0.3 
            });
            hands.onResults(onHandResults);
            
            const cameraUtils = new Camera(video, { 
                onFrame: async () => {
                    try {
                        await hands.send({image: video});
                    } catch (err) {
                        console.error('Error sending frame to MediaPipe:', err);
                    }
                }, 
                width: 640, 
                height: 480 
            });
            
            await cameraUtils.start();
            console.log('MediaPipe camera started successfully');
            
            // Video preview is hidden
            inputMode = 'hand';
            updateModeBtn();
        } catch (error) {
            console.error('MediaPipe setup failed:', error);
            inputMode = 'mouse';
            updateModeBtn();
            // 手势模式失败时不显示错误提示，静默切换到鼠标模式
        }
    }

    function onHandResults(results) {
        if (inputMode !== 'hand') return;
        
        // Video preview is hidden, but we still process hand data
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            
            // Convert normalized coordinates to screen coordinates (-1 to 1)
            // MediaPipe coordinates: x and y are normalized [0, 1], z is depth
            // We need to flip x and y to match screen coordinates
            handPointer.x = -(indexTip.x * 2 - 1);
            handPointer.y = -(indexTip.y * 2 - 1);

            // Calculate pinch distance (normalized coordinates)
            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            // Adjust pinch threshold for better detection
            // 0.05 = 5% of screen (balanced threshold)
            isPinching = pinchDist < 0.05;
            
            // Debug: log hand detection (only occasionally to avoid spam)
            if (Math.random() < 0.01) { // 1% chance to log
                console.log('Hand detected - x:', handPointer.x.toFixed(2), 'y:', handPointer.y.toFixed(2), 'pinch:', isPinching, 'dist:', pinchDist.toFixed(3));
            }
        } else {
            isPinching = false;
            // Reset hand pointer when no hand detected
            handPointer.x = 0;
            handPointer.y = 0;
            
            // Debug: log when no hand detected (occasionally)
            if (Math.random() < 0.01) {
                console.log('No hand detected in frame');
            }
        }
    }

    function updateStatus(text) {
        const el = document.getElementById('status-text');
        el.style.opacity = text ? 1 : 0;
        el.innerText = text;
    }

    let guidanceTimeout = null;
    let cardDrawTime = null;

    function startGuidanceCycle() {
        // 清除之前的定时器
        if (guidanceTimeout) {
            clearTimeout(guidanceTimeout);
            guidanceTimeout = null;
        }
        
        // 刚进入准备抽取时显示第一句
        updateStatus('闭上双眼，在心中默念你的疑问');
        
        // 1s后显示第二句
        guidanceTimeout = setTimeout(() => {
            updateStatus('轻捏手指，抽取属于你的启示');
        }, 1000);
    }

    function showReleaseGuidance() {
        // 清除之前的定时器
        if (guidanceTimeout) {
            clearTimeout(guidanceTimeout);
            guidanceTimeout = null;
        }
        
        // 抽取卡牌1s后显示第三句
        guidanceTimeout = setTimeout(() => {
            updateStatus('松开手指，让答案归于宇宙');
            
            // 保持1s后消失
            guidanceTimeout = setTimeout(() => {
                updateStatus('');
            }, 1000);
        }, 1000);
    }

    function updateCardInfo(cardName, isUpright) {
        const nameEl = document.getElementById('card-name');
        const interpEl = document.getElementById('card-interpretation');
        
        if (cardName) {
            // Display card name with Chinese name and reversed indicator
            const chineseName = CARD_NAMES_CN[cardName] || cardName;
            const englishName = cardName.toUpperCase();
            const reversedText = isUpright ? "" : " (逆位)";
            const nameText = `${chineseName} ${englishName}${reversedText}`;
            nameEl.innerText = nameText;
            nameEl.style.opacity = 1;
            
            // Get interpretation from CARD_INTERPRETATIONS
            const cardInterpretation = CARD_INTERPRETATIONS[cardName];
            if (cardInterpretation) {
                const interpText = isUpright ? cardInterpretation.upright : cardInterpretation.reversed;
                interpEl.innerText = interpText;
            } else {
                // Fallback if interpretation not found
                interpEl.innerText = "这是你的命运指引";
            }
            interpEl.style.opacity = 1;
        } else {
            // Hide both elements
            nameEl.style.opacity = 0;
            interpEl.style.opacity = 0;
        }
    }

    window.toggleInputMode = function() {
        inputMode = inputMode === 'mouse' ? 'hand' : 'mouse';
        updateModeBtn();
    }

    function updateModeBtn() {
        const btn = document.getElementById('btn-mode');
        btn.innerHTML = inputMode === 'mouse' ? 'MOUSE' : 'HAND';
        // Video preview is always hidden
    }
</script>
</body>
</html>